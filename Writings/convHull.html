
<html>
    <head>
        <meta name="viewport" content="width=device-width">
        <title>On Convex Hulls</title>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
            MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']]
                }
            };
        </script>
    </head>



<body>
    <div id="main">
        <center>
        <h1><b>Convex Hulls</b></h1>
        </center>
        <h3>Introduction</h3>
        <p>
        Consider \(X \subseteq \mathbb{R}^n\). Then the <b>Convex Hull</b> of X, \(co(X)\) is the set:
        </p>
        <center>
        \( 
            co(X) = \left\lbrace \sum_{i=1}^k \lambda_i x_i | x_1,...,x_k \in X; \lambda_i \geq 0, i=1,...,k; \sum_{i=1}^k \lambda_i = 1 \right\rbrace
        \)
        </center>
        <p>
        In plain English, it's the smallest convex set such that every point in X is within co(X). For me, this summer has been spent working with these objects,
        and I've come across a lot of interesting maths in the process. The primary context is from the world of mathematical finance. Specifically, on prior work 
        done in [1]. My work has been focused on these objects within themselves however, and less on the finanicla modelling in the afforementioned paper.
        </p>

        <p>
        In this brief article, I would like to discuss some of the different approaches for calculating convex hulls of functions, rather than sets. 
        </p>

        <h3>A look at the different methods</h3>
        The first method I looked at is that of the "Monotone-Chain" (MC) algorithm [2]. For a set of points in the plain, this algorithm starts by drawing a line between
        the left and rightmost points, leaving two sections of the set to have their upper and lower hulls respectively. It assumes points are in the hull, and removes
        them if the sequence of points doesn't make a counter clockwise term. This assures the convexity of the hull. For each subhull, the algorithm runs in \( \mathcal{O}(n)\) time.
        Overall, it runs in \(\mathcal{O}(nlogn)\) time. So, let's take a look at it in action!

        <center>
        <input type="image" src="../figures/mono.png">
        </center>

        You can see this randomly generated function in blue has a relatively boring hull in red, but the method calculates it perfectly. Below we look at the performance of this algorithm
        compared to another algoritm developed by the author of [1] (This algorithm isn't published yet). We can see that the MC chain algorithm when applied to functions in this way does 
        indeed run in linear time, due to only having to calculate the lower hull. WE can also see how consistent the MC algorithm is 
        when running on these randomly produced dataset. The reason for this is currently unknown but being looked into.
        
        <center>
            <input type="image" src="../figures/rouxVSmono.png">
        </center>

        Next up, and the last algoritm that was compared with the in-testing algorithm mentioned prior is the "Quickhull" algorithm [3]. This is known as the best in the business
        at the minute. This works by splitting adjacent points, and connecting points furtherst from that line to the hull, starting again with the two most extreme x-valued points.
        This works really effectively, and is essentially a divide and conquer technique. In the worst case scenario, it runs in 
        \(\mathcal{O}(nlog(r)) \) where n is the total number of points, and r is the number of points already in the hull. One interesting thing to note is that quickhull is much slower
        when working on points that follow the circumfrence of a circle. This is due to the amount of dividing that has to be done.
        Below you can see how this algorithm compares with the other two afforementioned algorithms.

        <center>
            <input type="image" src="../figures/full_comparison.png">
        </center>

        We can see that Quickhull also shares the same trait as "RouxHull" in being a bit less consistent, but overall it can be seen how much quicker it is. Even then, it is clearly quicker than
        the other two algorithms, and for the most part runs in linear time.

        <center>
            <h3>Closing Remarks</h3>
        </center>

        The world of Convex Hulls is a very interesting one, with lots of applications in a variety of fields. For that reason I believe work being done on 
        efficiently calculating these is very important to modern mathematics, and I'm excited to see what other problems they're able to be applied to.

        <center>
            <h3>References</h3>
        </center>
        [1] Roux, Alet, and Zhikang Xu. "Optimal investment and contingent claim valuation with exponential disutility under proportional transaction costs." arXiv preprint arXiv:1909.06260 (2019).
        <br>
        [2] https://algorithmist.com/wiki/Monotone_chain_convex_hull (Accessed 18/08/21)
        <br>
        [3] Barber, C. Bradford, David P. Dobkin, and Hannu Huhdanpaa. "The quickhull algorithm for convex hulls." ACM Transactions on Mathematical Software (TOMS) 22, no. 4 (1996): 469-483


    </div>
</body>

</html>